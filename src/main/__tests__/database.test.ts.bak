/**
 * @jest-environment node
 */
import { DatabaseManager, Patch, Bank } from '../database';
import path from 'path';
import fs from 'fs';
import os from 'os';

// Mock electron app
jest.mock('electron', () => ({
  app: {
    getPath: jest.fn().mockImplementation((name: string) => {
      if (name === 'userData') {
        return path.join(os.tmpdir(), 'test-app-data');
      }
      return '/tmp/test-app-data';
    })
  }
}));

describe('DatabaseManager (async)', () => {
  let db: DatabaseManager;
  let dbPath: string;

  beforeAll(async () => {
    // Use a unique temp file for each test
    dbPath = path.join(os.tmpdir(), `moog-muse-test.db`);
    
    // Ensure the database file doesn't exist before starting
    if (fs.existsSync(dbPath)) {
      fs.unlinkSync(dbPath);
    }
    
    // Create and initialize the database instance
    db = await DatabaseManager.create(dbPath);

    // Verify tables were created by attempting to use them
    const testBank: Bank = { 
      name: 'Test Bank', 
      libraryId: 1, 
      type: 'patch', 
      systemName: 'Test Bank', 
      fingerprint: 'test-library-fingerprint'
    };
    await db.createBank(testBank);
    
    const testSequence: Sequence = {
      name: 'Test Sequence',
      content: 'test sequence content',
      fingerprint: 'test-sequence-checksum'
    };
    await db.createSequence(testSequence);
    const sequences = await db.getSequencesByFingerprint('test-sequence-checksum');
    expect(sequences.length).toBeGreaterThan(0);
    
    const testPatch: Patch = {
      id: 1,
      name: 'Test Patch',
      content: 'test content',
      fingerprint: 'test-checksum',
      favorited: false,
      tags: []
    };
    
    await db.savePatch(testPatch);
    const patches = await db.getPatches();
    expect(patches.length).toBeGreaterThan(0);
  });

  afterEach(async () => {
    // Clean up after each test
    await db.clearAllTables();
    // Close and recreate the database instance
    await db.close();
    db = await DatabaseManager.create(dbPath);
  });

  afterAll(async () => {
    // Close the database and delete the test file
    await db.close();
    if (fs.existsSync(dbPath)) {
      fs.unlinkSync(dbPath);
    }
  });

  it('should save and get a patch', async () => {
    // Create bank first
    const testBank: Bank = { 
      name: 'Test Bank', 
      libraryId: 1, 
      type: 'patch', 
      systemName: 'Test Bank', 
      fingerprint: 'test-library-fingerprint'
    };
    await db.createBank(testBank);

    const testPatch: Patch = {
      id: 1,
      name: 'Test Patch',
      content: 'test content',
      fingerprint: 'checksum123',
      favorited: false,
      tags: []
    };
    
    await db.savePatch(testPatch);
    const patches = await db.getPatches();
    expect(patches.length).toBeGreaterThan(0);
    expect(patches[0].name).toBe('Test Patch');
    expect(patches[0].fingerprint).toBe('checksum123');
    expect(patches[0].content).toBe('test content');
    expect(patches[0].favorited).toBe(false);
    expect(patches[0].tags).toEqual([]);
  });

  it('should check if a patch exists by checksum', async () => {
    // Create bank first
    const testBank: Bank = { 
      name: 'Test Bank', 
      libraryId: 1, 
      type: 'patch', 
      systemName: 'Test Bank', 
      fingerprint: 'test-library-fingerprint'
    };
    await db.createBank(testBank);
    const banks = await db.getBankByFingerprint('test-library-fingerprint');
    expect(banks.length).toBeGreaterThan(0);

    // Insert a patch with the expected checksum
    const testPatch: Patch = {
      path: '/test/patch/exist.mmp',
      name: 'Test Patch',
      loved: false,
      category: '',
      tags: [],
      bank: 'Test Bank',
      library: 'Test Library',
      checksum: 'checksum123',
      custom: false
    };
    await db.savePatch(testPatch);
    const exists = await db.patchExists('checksum123');
    expect(exists).toBe(true);
    const notExists = await db.patchExists('doesnotexist');
    expect(notExists).toBe(false);
  });

  it('should save and get a bank', async () => {
    const bank: Bank = { name: 'Bank1', library: 'Lib1', custom: true };
    await db.saveBank(bank);
    const banks = await db.getBanks();
    expect(banks.length).toBeGreaterThan(0);
    expect(banks[0].name).toBe('Bank1');
    expect(banks[0].library).toBe('Lib1');
    expect(banks[0].custom).toBe(true);
  });

  it('should save and get a sequence', async () => {
    await db.saveSequence('Seq1', 'seqdata');
    const seqs = await db.getSequences();
    expect(seqs.length).toBeGreaterThan(0);
    expect(seqs[0].name).toBe('Seq1');
  });

  it('should delete a patch', async () => {
    const testPatch: Patch = {
      path: '/test/patch/delete.mmp',
      name: 'ToDelete',
      loved: false,
      category: '',
      tags: [],
      bank: 'Test Bank',
      library: 'Test Library',
      checksum: 'delchecksum',
      custom: false
    };
    await db.savePatch(testPatch);
    const patches = await db.getPatches();
    const patch = patches.find(p => p.checksum === 'delchecksum');
    expect(patch).toBeDefined();
    if (patch && patch.id !== undefined) {
      await db.deletePatch(patch.id);
    } else {
      throw new Error('Patch has no ID');
    }
    const afterDelete = await db.getPatches();
    expect(afterDelete.find(p => p.checksum === 'delchecksum')).toBeUndefined();
  });

  it('should delete a sequence', async () => {
    await db.saveSequence('SeqToDelete', 'seqdata');
    const seqs = await db.getSequences();
    const seq = seqs.find(s => s.name === 'SeqToDelete');
    expect(seq).toBeDefined();
    await db.deleteSequence(seq!.id);
    const afterDelete = await db.getSequences();
    expect(afterDelete.find(s => s.name === 'SeqToDelete')).toBeUndefined();
  });
});